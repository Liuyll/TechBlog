## 朱-刘算法

朱刘算法分为以下步骤：

![image-20201004164157648](/Users/liuyl/Library/Application Support/typora-user-images/image-20201004164157648.png)

#### 1-最短弧集

最短弧集是指每一个非root节点的最小入度节点

这里很明显，如果一个非root节点没有入度，那它肯定是一个孤立点，不可能生成一颗树，此时算法退出。

注意，这里遇到在后续步骤<b>3</b>标识flag为true的节点时便跳过(它被当做环内的点已经处理过了)

这个最短弧集，其实应该叫做最短入度弧集。这也是我们最终返回的结构。

#### 2-判断弧集是否存在环

判断求出的最小弧集是否存在环

方法非常简单，我们知道弧集上每个节点的最小入度节点，通过类似并查集的方式递归查找root节点是否为祖先即可判断是否存在环。

很明显，有环的节点，不可能能连接root节点。



#### 3-环收缩

如果一个地方出现了环，那就从出现环的这个点执行以下步骤:

+ 把整个环当成一个点
+ 入度收缩
+ 出度收缩

注意，上述的收缩需要循环对环里的所有点都进行

首先标识环内所有点

```
for(let k = 0; k < ring_node_count;k++) {
	flag[k] = true
}
flag[i] = false // i是环进入点
```



```
for(int k=1; k<=n; ++k) {
	if(vis[k]) {  // 在环中点点
    for(int j=1; j<=n; j++)if(!vis[j])   // 不在环中的点
    {
      // 出度收缩
      // i是环起始点
      if(w[i][j] > w[k][j]) w[i][j] = w[k][j];

      // 入度收缩
      // pre是前驱节点,INF表示不连通
      if(w[j][k]<INF && w[j][k]-w[pre[k]][k] < w[j][i])
      w[j][i] = w[j][k] - w[pre[k]][k];
    }
  }
}

```

这样得到了一个入度和出度都是相对最小(不构成环的情况下)的收缩环(环被收缩为一个点)



##### 几个重点

环收缩作为算法最重要的部分，有几个细节需要详细看一下

+ 环入度的pre节点是否需要更新：

  不需要，把环抽象成一个点后。进入点的最小入度弧并不在环内，所以不用管。

+ 环是怎么破坏的：

  虽然我们更新了环内节点入度和出度的最小值，但没有明显的代码将环破坏掉。

  实际上，我们在标记环内元素后有这一行代码

  ```
  flag[i] = false
  ```

  这意味着，环入口被重新加入计算最小弧集的队列。此时会尝试重新计算到另一个相对最小的入度，重新执行算法，直到环消失。所以，环的破除实际上是穷举得到的。

#### 4-重复123

重复123，直到最小弧集没有环为止。



## Tarjan



