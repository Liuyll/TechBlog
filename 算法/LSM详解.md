## LSM详解



### b类树导致的内存索引过大的问题

不管是`b+tree`还是`b-tree`，都会遇到索引位置占用内存大的问题，实际对两者来说，都是一个`key`对应一个`value`，有多少个值，就必须对应相同的`key`。

实际上，`b+tree`和`b-tree`虽然都是有序的树，但储存的数据依然是`key -> value`。

如果我们的`key`是有序的，那实际上不用`key -> value`的结构，而可以用`key -> value block`，即一个`key`对应一个`value块`的结构，这样我们只需要找到对应的value块首部，然后在内部进行顺序搜索。



#### memtable

当然，我们在数据量小的时候依然合适使用树形结构来储存数据，此时我们在内存里构建一个`BST`或者`RBT`，这个树形结构我们叫做`memtable`，后续我们会通过这个`memtable`来生成我们刚才提交的`value block`。



#### SSTable

上文提到的`value block`，我们为他起一个名字叫做`SSTable`，它有以下几个特点：

+ `SSTable`是有序的结构，每个`SSTable`对应一个`key`
+ `SSTable`理论上可以无限写入(被追加写入内存)，但因为内存不是无限大的，它必须在某一时刻被整理合并

我们下面将围绕`SSTable`讲起整个`LSM`



### SSTable的查询

对于大量的`SSTable`来说，一个`key`是否存在，可以通过`bloom filter`来判断。

#### bloom filter

布隆过滤器在`k-v`结构的储存里非常常见，它提供了这样一种功能：能肯定判断不存在，但不能判断是否存在。

这意味着很容易用它来判否，即判断一个`key`是否存在。

`bloom filter`的原理是通过多个`hash`映射单个`key`到不同的位置上面，判断的适合反向执行`hash`，看对应位置是否被置为1。很显然，即使对应位置都被置为1，也不能说明该值就存在。但相反，如果有某个位置的值不为1，那这个`key`肯定就不存在。

这样一个有单个`key`对应多个`hash`的`map`表就叫做`bloom filter`。

实现上，我们可以用`bitmap`来实现，当然要注意不要有太大`value`的`hash`值出现。



### SSTable的合并

