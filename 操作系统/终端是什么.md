## 终端

终端实际上是一套字符串设备，用来连接物理设备和主机，接受输入，反馈输出。



### 伪终端

伪终端不连接任何物理机，有两个很典型的伪终端

+ 桌面打开控制台

+ ssh连接

  通过ssh连接后，远端主机为我们分配一个伪终端

  ```
  tty
  -> /dev/pts/0
  ```

  

### 虚拟终端(/dev/tty)

虚拟终端不直接连接物理机，但它跟伪终端又不同。

虚拟终端就是默认的`/dev/tty1 - /dev/tty6`这六个控制设备。

实际上，虚拟终端是我们无法看到的。它的输出直接输出到控制终端，此时显示器才能显示它的输出。



#### 控制终端(/dev/console)

实际上，我们用来显示的只有一个设备(不管你有多少个显示器)。那么这个设备的端口就作为我们的控制终端，主机与你通信时就是用这个端口。

当然，你还需要一个虚拟终端来进行真实的通信(分配一个tty)，控制终端只用来显示。

实际上，我们使用`alt + F[1-6]`就是使用不同的tty



## session

当然，单有终端没有任何用。我们需要在上面执行一些进程，而这些进程又需要进行管理(什么在前台执行，什么在后台执行，什么时候退出)，这个管理的进程就叫做`Session`

#### 如何终止一个session

实际上，每个Session都有一个领头的线程，这个线程一般是打开这个终端时创建的shell进程。

我们可以通过`exit`或者直接`kill`调这个进程，那么这个`Session`就会丢失联系，此时内核监听到`hangup`后，会给对应的`Session`下发`hangup`（HUP）命令，各`Session`接收后自行终止其下进程。

### 后台进程

#### nohup

我们经常使用`nohup`或者`&`来开启一个后台线程，但这个后台不是指的我们通过`ctrl + z`放到后台运行的进程。

上面提到过`Session`的终止，但是一旦我们调用了`nohup`来执行一个线程，那么它就不会受到HUP命令的影响，因此`Session`终止也就管不到它。

实际上，它还是会引用这个Session，此时Session并不会被回收，当然它的父进程会变成系统主进程。



#### setpid

另外还要一个方法也可以让进程后台运行，就是把它作为领头进程加入到另一个`Session`里。

通过`setpid`，可以把对应的进程加入到新的`Session`里去执行，它的`sid`也不再是之前`Session`的sid了，此时只有它自行退出或者`kill`掉，这个`Session`才会结束。



而我们通过`fg`调到前台执行的命令又会把输出打印到控制终端上面





